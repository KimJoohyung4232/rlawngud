# app.py
import io
import re
import hashlib
from pathlib import Path

import streamlit as st
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import torch
import requests
from ultralytics import YOLO

# ==================== ê¸°ë³¸ ì„¤ì • ====================
st.set_page_config(page_title="YOLO íƒì§€ê¸°", page_icon="ğŸ§ ", layout="centered")

BASE_DIR = Path(__file__).parent
MODEL_PATH = BASE_DIR / "best.pt"

# ğŸ”¥ GitHub Releaseì—ì„œ ëª¨ë¸ ë°›ì•„ì˜¤ê¸°(êµ¬ê¸€ë“œë¼ì´ë¸Œ X)
#   ë¦´ë¦¬ìŠ¤: v1.0.0, ì—ì…‹ íŒŒì¼ëª…: default.pt  (ë„¤ ìŠ¤í¬ë¦°ìƒ· ê¸°ì¤€)
MODEL_URL = "https://github.com/KimJoohyung4232/rlawngud/releases/download/v1.0.0/default.pt"
# ë¦´ë¦¬ìŠ¤ í˜ì´ì§€ì˜ sha256 ì „ì²´ê°’ì„ ë³µë¶™í•´ì„œ ë„£ì–´ì£¼ì„¸ìš” (ìŠ¤í¬ë¦°ìƒ·ì— ë‚˜ì˜¨ ê°’ì˜ ì•ë¶€ë¶„ ì˜ˆì‹œ)
MODEL_SHA256 = "35b9cfe36e700c3ce7f4db3f7..."  # â† ë¦´ë¦¬ìŠ¤ í™”ë©´ì˜ sha256 ì „ì²´ ë¬¸ìì—´ë¡œ êµì²´!

DEVICE = "mps" if torch.backends.mps.is_available() else (
    "cuda" if torch.cuda.is_available() else "cpu"
)

# ì˜ì–´ â†’ í•œê¸€ ë§¤í•‘
KOR_LABELS = {
    "jjajangmyeon": "ì§œì¥ë©´",
    "jajangmyeon": "ì§œì¥ë©´",
    "jjajang": "ì§œì¥ë©´",
    "jajang": "ì§œì¥ë©´",
    "blackbean_noodles": "ì§œì¥ë©´",
    "blackbean": "ì§œì¥ë©´",
    "ramen": "ë¼ë©´",
    "noodles": "ë©´",
}
def to_kor(name: str) -> str:
    return KOR_LABELS.get(str(name).strip().lower(), name)

# ==================== ìœ í‹¸ ====================
def sha256_of(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def download_from_github_release(url: str, dst: Path):
    dst.parent.mkdir(parents=True, exist_ok=True)
    with requests.get(url, stream=True, timeout=60) as r:
        r.raise_for_status()
        with open(dst, "wb") as f:
            for chunk in r.iter_content(1024 * 1024):
                if chunk:
                    f.write(chunk)

def looks_like_html(path: Path) -> bool:
    try:
        with open(path, "rb") as f:
            head = f.read(512).lower()
        return b"<html" in head or b"<!doctype html" in head
    except Exception:
        return True

def likely_broken(path: Path) -> bool:
    # 1) 1MB ë¯¸ë§Œì´ë©´ ê±°ì˜ í™•ì‹¤íˆ ê¹¨ì§
    if not path.exists() or path.stat().st_size < 1_000_000:
        return True
    # 2) HTML í˜ì´ì§€ê°€ ì €ì¥ëœ ê²½ìš°
    if looks_like_html(path):
        return True
    # 3) SHA256ì´ ì œê³µë˜ë©´ ê²€ì¦
    if MODEL_SHA256 and len(MODEL_SHA256) > 10:
        try:
            return sha256_of(path) != MODEL_SHA256.lower()
        except Exception:
            return True
    return False

# ==================== í°íŠ¸ ìœ í‹¸ ====================
def get_korean_font(size=18):
    font_candidates = [
        str(BASE_DIR / "fonts" / "NotoSansKR-Regular.ttf"),
        "/System/Library/Fonts/AppleSDGothicNeo.ttc",
        "C:/Windows/Fonts/malgun.ttf",
    ]
    for p in font_candidates:
        try:
            return ImageFont.truetype(p, size)
        except Exception:
            continue
    return ImageFont.load_default()

# ==================== ëª¨ë¸ ë¡œë“œ ====================
@st.cache_resource
def load_model(path: Path):
    # ëª¨ë¸ íŒŒì¼ ì—†ê±°ë‚˜/ì†ìƒ ì‹œ GitHubì—ì„œ ì¬ë‹¤ìš´
    if likely_broken(path):
        with st.spinner("ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘... (GitHub Release)"):
            try:
                download_from_github_release(MODEL_URL, path)
            except Exception as e:
                st.error(f"ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: {e}")
                st.stop()
        if likely_broken(path):
            st.error("ëª¨ë¸ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ë¦´ë¦¬ìŠ¤ì˜ sha256 ê°’ê³¼ URLì„ í™•ì¸í•´ ì£¼ì„¸ìš”.")
            st.stop()

    # YOLO ê°€ì¤‘ì¹˜ ë¡œë“œ
    return YOLO(str(path))

# ==================== ë°•ìŠ¤ ë“œë¡œì‰ ====================
def draw_boxes(pil_img: Image.Image, results, names_dict, font=None):
    img = pil_img.copy()
    draw = ImageDraw.Draw(img)
    font = font or get_korean_font(18)

    for r in results:
        if r.boxes is None:
            continue
        for box in r.boxes:
            x1, y1, x2, y2 = [int(v) for v in box.xyxy[0].tolist()]
            conf = float(box.conf[0].item())
            cls  = int(box.cls[0].item())
            cls_eng = names_dict.get(cls, str(cls))
            cls_name = to_kor(cls_eng)

            draw.rectangle([(x1, y1), (x2, y2)], outline=(0, 255, 0), width=3)
            label = f"{cls_name} {conf:.2f}"
            try:
                tw, th = draw.textbbox((0, 0), label, font=font)[2:]
            except Exception:
                tw, th = font.getsize(label)
            pad = 4
            if y1 - th - pad * 2 < 0:
                bx1, by1 = x1, y1
                bx2, by2 = x1 + tw + pad * 2, y1 + th + pad * 2
                text_xy = (x1 + pad, y1 + pad)
            else:
                bx1, by1 = x1, y1 - th - pad * 2
                bx2, by2 = x1 + tw + pad * 2, y1
                text_xy = (x1 + pad, y1 - th - pad)

            draw.rectangle([(bx1, by1), (bx2, by2)], fill=(0, 255, 0))
            draw.text(text_xy, label, font=font, fill=(0, 0, 0))
    return img

def summarize_prediction(rows):
    if not rows:
        return "ì•„ì§ í™•ì‹ í•˜ê¸° ì–´ë ¤ì›Œìš”. (íƒì§€ ê²°ê³¼ ì—†ìŒ)"
    totals = {}
    for r in rows:
        totals[r["class_name"]] = totals.get(r["class_name"], 0.0) + float(r["conf"])
    best_name = max(totals, key=totals.get)
    best_name_kor = to_kor(best_name)
    return f'ì´ ì‚¬ì§„ì€ **"{best_name_kor}"**ìœ¼ë¡œ ì¶”ì •ë©ë‹ˆë‹¤.'

# ==================== UI ====================
st.title("ğŸ§  YOLO ê°ì²´ íƒì§€ (Streamlit)")
st.caption(f"Device: {DEVICE}")

with st.sidebar:
    st.subheader("ì„¤ì •")
    conf_thres = st.slider("Confidence", 0.1, 0.9, 0.25, 0.05)
    iou_thres  = st.slider("IoU", 0.1, 0.9, 0.45, 0.05)
    st.write("ëª¨ë¸:", f"`{MODEL_PATH.name}`")
    if st.button("ğŸ”„ ì´ˆê¸°í™”"):
        for k in ("pred_img", "det_rows", "summary_msg", "uploaded_img"):
            st.session_state.pop(k, None)
        st.rerun()

# ì—…ë¡œë“œ
st.markdown("### 1) ì´ë¯¸ì§€ ì˜¬ë¦¬ê¸°")
up = st.file_uploader("ì´ë¯¸ì§€ ì„ íƒ (jpg/png)", type=["jpg", "jpeg", "png"])
if up:
    pil_img = Image.open(io.BytesIO(up.read())).convert("RGB")
    st.session_state["uploaded_img"] = pil_img
    st.image(pil_img, caption="ì—…ë¡œë“œ ì´ë¯¸ì§€", use_container_width=True)

# ë²„íŠ¼
st.markdown("### 2) ì˜ˆì¸¡ ì‹¤í–‰")
c1, c2 = st.columns(2)
run_btn   = c1.button("ğŸš€ ì˜ˆì¸¡í•˜ê¸°", use_container_width=True)
clear_btn = c2.button("ğŸ—‘ ê²°ê³¼ ì§€ìš°ê¸°", use_container_width=True)

if clear_btn:
    for k in ("pred_img", "det_rows", "summary_msg"):
        st.session_state.pop(k, None)
    st.toast("ê²°ê³¼ ì´ˆê¸°í™”!", icon="ğŸ§½")

# ==================== ì¶”ë¡  ====================
model = load_model(MODEL_PATH)

if run_btn:
    if "uploaded_img" not in st.session_state:
        st.warning("ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì˜¬ë ¤ì¤˜!")
    else:
        with st.spinner("ëª¨ë¸ ì¶”ë¡  ì¤‘..."):
            dv = "mps" if DEVICE == "mps" else (0 if DEVICE == "cuda" else "cpu")
            img_np = np.array(st.session_state["uploaded_img"])
            results = model.predict(
                source=img_np, conf=conf_thres, iou=iou_thres,
                verbose=False, device=dv
            )
            names = model.names

            out_img = draw_boxes(st.session_state["uploaded_img"], results, names)
            st.session_state["pred_img"] = out_img

            rows = []
            for r in results:
                if r.boxes is None:
                    continue
                for box in r.boxes:
                    cls  = int(box.cls[0].item())
                    conf = float(box.conf[0].item())
                    x1, y1, x2, y2 = [int(v) for v in box.xyxy[0].tolist()]
                    cls_eng = names.get(cls, str(cls))
                    cls_kor = to_kor(cls_eng)
                    rows.append({
                        "class_id": cls,
                        "class_name": cls_kor,
                        "conf": round(conf, 4),
                        "x1": x1, "y1": y1, "x2": x2, "y2": y2
                    })
            st.session_state["det_rows"]  = rows
            st.session_state["summary_msg"] = summarize_prediction(rows)

        st.success("ì˜ˆì¸¡ ì™„ë£Œ!")

# ==================== ê²°ê³¼ í‘œì‹œ ====================
if "pred_img" in st.session_state:
    st.markdown("### 3) ê²°ê³¼")
    st.image(st.session_state["pred_img"], caption="íƒì§€ ê²°ê³¼", use_container_width=True)

    msg = st.session_state.get("summary_msg")
    if msg:
        st.info(msg)

    if st.session_state.get("det_rows"):
        st.markdown("#### íƒì§€ ë°•ìŠ¤ ëª©ë¡")
        st.json(st.session_state["det_rows"])
